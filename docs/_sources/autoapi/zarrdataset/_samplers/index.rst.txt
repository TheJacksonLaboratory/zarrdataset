zarrdataset._samplers
=====================

.. py:module:: zarrdataset._samplers


Classes
-------

.. autoapisummary::

   zarrdataset._samplers.PatchSampler
   zarrdataset._samplers.BlueNoisePatchSampler


Module Contents
---------------

.. py:class:: PatchSampler(patch_size: Union[int, Iterable[int], dict], stride: Union[int, Iterable[int], dict, None] = None, pad: Union[int, Iterable[int], dict, None] = None, min_area: Union[int, float] = 1, spatial_axes: str = 'ZYX', allow_incomplete_patches: bool = False)

   Bases: :py:obj:`object`


   Patch sampling algorithm to retrieve image patches/windows from images.

   If the image used for extracting patches has a mask associated to it, only
   patches from masked regions of the image are retrieved.

   :param patch_size: Size in pixels of the patches extracted on each axis. Only rectangular
                      patches (hyper-cuboids) are supported by now. If a single int is
                      passed, that size is used for all dimensions. If an iterable (list,
                      tuple) is passed, each value will be assigned to the corresponding axes
                       in `spatial_axes`, the size of `patch_size` must match the lenght of
                      `spatial_axes'. If a dict is passed, this should have at least the size
                       of the patch of the axes listed in `spatial_axes`.  Use the same
                      convention as how Zarr structure array chunks in order to handle patch
                      shapes and channels correctly.
   :type patch_size: Union[int, Iterable[int], dict]
   :param stride: Distance in pixels of the movement of the sampling sliding window.
                  If `stride` is less than `patch_size` for an axis, patches will have an
                  overlap between them. This is usuful in inference mode for avoiding
                  edge artifacts. If None is passed, the `patch_size` will be used as
                  `stride`.
   :type stride: Union[int, Iterable[int], dict, None]
   :param pad: Padding in pixels added to the extracted patch at each specificed axis.
   :type pad: Union[int, Iterable[int], dict, None]
   :param min_area: Minimum patch area covered by the mask to consider it samplable. A
                    number in range [0, 1) will be used as percentage of the patch size. A
                    number >= 1 will be considered as the number of minimum patch pixels
                    covered by the mask.
   :type min_area: Union[int, float]
   :param spatial_axes: The spatial axes from where patches can be extracted.
   :type spatial_axes: str
   :param allow_incomplete_patches: Allow to retrieve patches that are smaller than the patch size. This is
                                    the case of samples at the edge of the image that are usually smaller
                                    than the specified patch size.
   :type allow_incomplete_patches: bool


   .. py:attribute:: _max_chunk_size


   .. py:attribute:: spatial_axes


   .. py:attribute:: _patch_size


   .. py:attribute:: _stride


   .. py:attribute:: _pad


   .. py:attribute:: _min_area


   .. py:attribute:: _allow_incomplete_patches


   .. py:method:: _compute_corners(coordinates: numpy.ndarray, scale: numpy.ndarray) -> numpy.ndarray


   .. py:method:: _compute_reference_indices(reference_coordinates: numpy.ndarray, reference_axes_sizes: numpy.ndarray) -> Tuple[List[numpy.ndarray], List[Tuple[int]]]


   .. py:method:: _compute_overlap(corners_coordinates: numpy.ndarray, reference_per_axis: numpy.ndarray) -> Tuple[numpy.ndarray, numpy.ndarray]


   .. py:method:: _compute_grid(chunk_tlbr: dict, mask: zarrdataset._imageloaders.ImageBase, patch_size: dict, image_size: dict, min_area: float, allow_incomplete_patches: bool = False)


   .. py:method:: _compute_valid_toplefts(chunk_tlbr: dict, mask: zarrdataset._imageloaders.ImageBase, patch_size: dict, **kwargs)


   .. py:method:: _compute_toplefts_slices(chunk_tlbr: dict, valid_mask_toplefts: numpy.ndarray, patch_size: dict, pad: Union[dict, None] = None)


   .. py:method:: compute_chunks(image_collection: zarrdataset._imageloaders.ImageCollection) -> Iterable[dict]

      Compute the top-left positions of the chunks in which the image is
      divided before taking patches from them.

      The chunk size should match the zarr's chunk sizes to make the patch
      extraction more efficient.

      :param image: The image from where the patches are extracted.
      :type image: zarrdataset.ImageCollection

      :returns: **chunks_grids** -- Each valid chunk is returned in form of a slice that can be
                extracted from the image. The slices are stored as tuples, with one
                slice per axis.
      :rtype: list of tuples of slices



   .. py:method:: compute_patches(image_collection: zarrdataset._imageloaders.ImageCollection, chunk_tlbr: dict) -> Iterable[dict]


   .. py:method:: __repr__() -> str

      String representation of classes derived from PatchSampler.




.. py:class:: BlueNoisePatchSampler(patch_size: Union[int, Iterable[int], dict], resample_positions=False, allow_overlap=False, **kwargs)

   Bases: :py:obj:`PatchSampler`


   Patch sampler that retrieves patches from coordinates sampled using the
   Bridson sampling algorithm, also known as Blue-noise sampling algorithm.

   :param patch_size: Size in pixels of the patches extracted. Only squared patches are
                      supported by now.
   :type patch_size: int, iterable, dict
   :param resample_positions: Whether positions should be resampled for each new chunk or not.
   :type resample_positions: bool
   :param allow_overlap: Whether overlapping of patches is allowed or not.
   :type allow_overlap: bool


   .. py:attribute:: _base_chunk_tls
      :value: None



   .. py:attribute:: _resample_positions


   .. py:attribute:: _allow_overlap


   .. py:method:: compute_sampling_positions(force=False) -> None

      Compute the sampling positions using blue-noise sampling.

      :param force: Whether force resampling positions, or reuse existing positions.
      :type force: bool



   .. py:method:: _compute_valid_toplefts(chunk_tlbr: dict, mask: zarrdataset._imageloaders.ImageBase, patch_size: dict, **kwargs)


